package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"reflect"
	"strconv"
	"unicode"

	. "github.com/JonahSussman/prototypal-language/go/lot_types"
)

// --- TOKENIZATION SECTION ---

type token struct {
	kind    string
	lexeme  string
	line    int
	literal interface{}
}

func token_error(tok token, msg string) error {
	var lex string
	if tok.kind == "END_OF_FILE" {
		lex = "at EOF"
	} else {
		lex = tok.lexeme
	}
	return fmt.Errorf(fmt.Sprintf("[line %d] Error %s: %s", tok.line, lex, msg))
}

func tokenize(str_src string) (output []token, err error) {
	keywords := map[string]string{
		"and":    "AND",
		"do":     "DO",
		"elif":   "ELIF",
		"else":   "ELSE",
		"end":    "END",
		"false":  "FALSE",
		"fun":    "FUN",
		"if":     "IF",
		"let":    "LET",
		"nil":    "NIL",
		"or":     "OR",
		"return": "RETURN",
		"then":   "THEN",
		"true":   "TRUE",
		"while":  "WHILE",
	}

	src := []rune(str_src)
	start, curr, line := 0, 0, 1
	var tokens []token

	// General helpers
	add := func(k string, l interface{}) {
		t := token{
			kind:    k,
			lexeme:  string(src[start:curr]),
			line:    line,
			literal: l,
		}
		tokens = append(tokens, t)
	}
	at_end := func() bool { return curr >= len(src) }
	peek := func() rune {
		if at_end() {
			return '\x00'
		}
		return src[curr]
	}
	peek_next := func() rune {
		if curr+1 >= len(src) {
			return '\x00'
		}
		return src[curr+1]
	}
	advance := func() rune { curr++; return src[curr-1] }
	match := func(c rune) bool {
		if at_end() || src[curr] != c {
			return false
		}
		curr++
		return true
	}

	for !at_end() {
		start = curr
		c := advance()

		switch c {
		case '(':
			add("LPAREN", nil)
		case ')':
			add("RPAREN", nil)
		case '[':
			add("LBRACK", nil)
		case ']':
			add("RBRACK", nil)
		case '{':
			add("LCURLY", nil)
		case '}':
			add("RCURLY", nil)
		case ',':
			add("COMMA", nil)
		case '.':
			add("DOT", nil)
		case '-':
			add("MINUS", nil)
		case '+':
			add("PLUS", nil)
		case ':':
			add("COLON", nil)
		case ';':
			add("SEMICOLON", nil)
		case '*':
			add("STAR", nil)
		case '/':
			add("SLASH", nil)
		case '!':
			if match('=') {
				add("BANG_EQ", nil)
			} else {
				add("BANG", nil)
			}
		case '=':
			if match('=') {
				add("EQ_EQ", nil)
			} else {
				add("EQ", nil)
			}
		case '<':
			if match('=') {
				add("LESS_EQ", nil)
			} else {
				add("LESS", nil)
			}
		case '>':
			if match('=') {
				add("GREATER_EQ", nil)
			} else {
				add("GREATER", nil)
			}
		case '#':
			for peek() != '\n' && !at_end() {
				advance()
			}
		case ' ', '\r', '\t':
			break
		case '\n':
			line++
		case '"':
			for peek() != '"' && !at_end() {
				if peek() == '\n' {
					line++
				}
				advance()
			}

			if at_end() {
				return nil, fmt.Errorf("unterminated string")
			}
			advance()
			var str []rune

			// fmt.Println("Parsing string!")
			i := start + 1
			for i < curr-1 {
				if src[i] == '\\' {
					switch src[i+1] {
					case '\'':
						str = append(str, '\'')
						i++
					case '"':
						str = append(str, '"')
						i++
					case '\\':
						str = append(str, '\\')
						i++
					case '?':
						str = append(str, '?')
						i++
					case 'n':
						str = append(str, '\n')
						i++
					case 't':
						str = append(str, '\t')
						i++
					default:
						str = append(str, '\\')
					}
				} else {
					str = append(str, src[i])
				}
				i++

				// fmt.Printf("i is: %v\n", i)
				// fmt.Printf("s is: %v\n", str)
			}

			// fmt.Printf("i is: %v\n", i)
			// fmt.Printf("s is: %v\n", str)

			add("STR", string(str))
			// for peek() != '"' && !at_end() {
			// 	if peek() == '\n' {
			// 		line++
			// 	}
			// 	advance()
			// }
			// if at_end() {
			// 	return nil, fmt.Errorf("unterminated string")
			// }
			// advance()
			// var str []rune

			// for i, _ := range src[start+1 : curr-1] {
			// 	if src[i+1] == '\\' {
			// 		switch src[i+2] {
			// 		case '\'':
			// 			str = append(str, '\'')
			// 		case '"':
			// 			str = append(str, '"')
			// 		case '\\':
			// 			str = append(str, '\\')
			// 		case '?':
			// 			str = append(str, '?')
			// 		case 'n':
			// 			str = append(str, '\n')
			// 		case 't':
			// 			str = append(str, '\t')
			// 		default:
			// 			str = append(str, '\\')
			// 		}
			// 	} else {
			// 		str = append(str, src[i+1])
			// 	}
			// }

			// add("STR", string(str))
		default:
			if unicode.IsDigit(c) {
				for unicode.IsDigit(peek()) {
					advance()
				}
				if peek() == '.' && unicode.IsDigit(peek_next()) {
					advance()
				}
				for unicode.IsDigit(peek()) {
					advance()
				}
				res, e := strconv.ParseFloat(string(src[start:curr]), 64)
				if e != nil {
					return nil, e
				}
				add("NUM", res)

			} else if unicode.IsLetter(c) || c == '_' {
				for unicode.IsLetter(peek()) || unicode.IsDigit(peek()) || peek() == '_' {
					advance()
				}
				text := string(src[start:curr])
				kind := "SYM"
				if val, ok := keywords[text]; ok {
					kind = val
				}
				add(kind, text)
			} else {
				return nil, fmt.Errorf("Unexpected char: '" + string(c) + "'")
			}
		}
	}

	add("END_OF_FILE", "")

	return tokens, nil
}

// --- PARSING SECTION ---

// Parsing helper functions

func parse_at_end(tks []token, idx *int) bool {
	return tks[*idx].kind == "END_OF_FILE"
}
func parse_check(tks []token, idx *int, kind string) bool {
	return !parse_at_end(tks, idx) && tks[*idx].kind == kind
}
func parse_advance(tks []token, idx *int) (res token) {
	if !parse_at_end(tks, idx) {
		(*idx)++
	}
	return tks[*idx-1]
}
func parse_consume(tks []token, idx *int, kind string, m string) (token, error) {
	if parse_check(tks, idx, kind) {
		return parse_advance(tks, idx), nil
	}
	return token{}, token_error(tks[*idx], m)
}
func parse_synchronize(tks []token, idx *int) {
	parse_advance(tks, idx)
	for !parse_at_end(tks, idx) {
		if tks[*idx-1].kind == "SEMICOLON" {
			return
		}

		switch tks[*idx].kind {
		case "DO", "WHILE", "IF", "FUN", "LET", "PRINT":
			return
		}
		parse_advance(tks, idx)
	}
}
func parse_match(tks []token, idx *int, k string) bool {
	if !parse_check(tks, idx, k) {
		return false
	}

	parse_advance(tks, idx)
	return true
}
func parse_multimatch(tks []token, idx *int, v []string) int {
	for i, e := range v {
		if parse_check(tks, idx, e) {
			parse_advance(tks, idx)
			return i
		}
	}

	return -1
}

// Parsing main section (order as shown in grammar.bnf)

func parse(tokens []token) (exps []Exp, err error) {
	var idx int
	for !parse_at_end(tokens, &idx) {
		var exp Exp
		exp, err = parse_expr(tokens, &idx)

		if err != nil {
			return nil, err
		}

		exps = append(exps, exp)
	}

	return exps, nil
}

func parse_expr(tks []token, idx *int) (ret Exp, err error) {
	if parse_match(tks, idx, "DO") {
		ret, err = parse_do(tks, idx)
	} else if parse_match(tks, idx, "WHILE") {
		ret, err = parse_while(tks, idx)
	} else if parse_match(tks, idx, "IF") {
		ret, err = parse_if(tks, idx)
	} else if parse_match(tks, idx, "FUN") {
		ret, err = parse_fun(tks, idx)
	} else if parse_match(tks, idx, "LET") {
		ret, err = parse_let(tks, idx)
	} else if parse_match(tks, idx, "RETURN") {
		ret, err = parse_return(tks, idx)
	} else {
		ret, err = parse_assignment(tks, idx)
	}

	if err != nil {
		return nil, err
	}

	parse_match(tks, idx, "SEMICOLON")

	return
}

func parse_block(tks []token, idx *int, terms []string) (exp Exp, err error) {
	var block List
	for parse_multimatch(tks, idx, terms) < 0 {
		exp, err = parse_expr(tks, idx)
		if err != nil {
			return nil, err
		}
		block = append(block, exp)
	}
	(*idx)--
	return &Call{intern("__do"), block}, nil
}

func parse_do(tks []token, idx *int) (ret Exp, err error) {
	ret, err = parse_block(tks, idx, []string{"END"})
	if err != nil {
		return nil, err
	}

	_, err = parse_consume(tks, idx, "END", "Expect 'end' after do block.")
	if err != nil {
		return nil, err
	}

	return ret, nil
}

func parse_while(tks []token, idx *int) (ret Exp, err error) {
	ret, err = parse_expr(tks, idx)
	if err != nil {
		return nil, err
	}

	args := List{ret}

	parse_consume(tks, idx, "DO", "Expect 'do' after while condition.")
	if err != nil {
		return nil, err
	}

	ret, err = parse_block(tks, idx, []string{"END"})
	if err != nil {
		return nil, err
	}

	args = append(args, ret)

	parse_consume(tks, idx, "END", "Expect 'end' after while block.")
	if err != nil {
		return nil, err
	}

	return &Call{intern("__while"), args}, nil
}

func parse_if(tks []token, idx *int) (ret Exp, err error) {
	// return nil, token_error(tks[*idx], "'parse_if' not implemented.")
	x, err := parse_expr(tks, idx)
	if err != nil {
		return nil, err
	}

	args := List{x}

	_, err = parse_consume(tks, idx, "THEN", "Expect 'then' after if condition.")
	if err != nil {
		return nil, err
	}

	b, err := parse_block(tks, idx, []string{"ELIF", "ELSE", "END"})
	if err != nil {
		return nil, err
	}

	args = append(args, b)

	i := parse_multimatch(tks, idx, []string{"ELIF", "ELSE"})
	for i >= 0 {
		if i == 0 {
			e, err := parse_expr(tks, idx)
			if err != nil {
				return nil, err
			}
			args = append(args, e)

			_, err = parse_consume(tks, idx, "THEN", "Expect 'then' after elif condition.")
			if err != nil {
				return nil, err
			}

			b, err := parse_block(tks, idx, []string{"ELIF", "ELSE", "END"})
			if err != nil {
				return nil, err
			}

			args = append(args, b)
		} else {
			arg := Boolean(true)
			args = append(args, &arg)

			b, err := parse_block(tks, idx, []string{"END"})
			if err != nil {
				return nil, err
			}
			args = append(args, b)
		}

		i = parse_multimatch(tks, idx, []string{"ELIF", "ELSE"})
	}

	_, err = parse_consume(tks, idx, "END", "Expect 'end' after if block.")
	if err != nil {
		return nil, err
	}
	return &Call{intern("__if"), args}, nil
}

func parse_fun(tks []token, idx *int) (ret Exp, err error) {
	_, err = parse_consume(tks, idx, "LBRACK", "Expect '[' for fun parameter list.")
	if err != nil {
		return nil, err
	}

	var params List
	if !parse_check(tks, idx, "RBRACK") {
		for {
			tok, err := parse_consume(tks, idx, "SYM", "Expect Symbol in param list")
			if err != nil {
				return nil, err
			}
			params = append(params, intern(tok.literal.(string)))
			if !parse_match(tks, idx, "COMMA") {
				break
			}
		}
	}

	_, err = parse_consume(tks, idx, "RBRACK", "Expect ']' after parameter list.")
	if err != nil {
		return nil, err
	}

	e, err := parse_expr(tks, idx)
	if err != nil {
		return nil, err
	}

	return &Call{intern("__fun"), List{&params, e}}, nil
}

func parse_let(tks []token, idx *int) (ret Exp, err error) {
	tok, err := parse_consume(tks, idx, "SYM", "Expect symbol.")
	if err != nil {
		return nil, err
	}

	ret = intern(tok.literal.(string))

	_, err = parse_consume(tks, idx, "EQ", "Expect '=' after identifier.")
	if err != nil {
		return nil, err
	}

	x, err := parse_expr(tks, idx)
	if err != nil {
		return nil, err
	}

	return &Call{intern("__let"), List{ret, x}}, nil
}

func parse_return(tks []token, idx *int) (ret Exp, err error) {
	e, err := parse_expr(tks, idx)
	if err != nil {
		return nil, err
	}
	return &Call{intern("__return"), List{e}}, nil
}

func parse_assignment(tks []token, idx *int) (ret Exp, err error) {
	ret, err = parse_lor(tks, idx)
	if err != nil {
		return nil, err
	}

	if parse_match(tks, idx, "EQ") {
		equals := tks[*idx-1]
		value, err := parse_expr(tks, idx)
		if err != nil {
			return nil, err
		}

		if _, ok := ret.(*Symbol); ok {
			return &Call{intern("__assign"), List{ret, value}}, nil
		} else if e, ok := ret.(*Call); ok && e.Name == intern("__get") {
			return &Call{intern("__set"), List{e.Args[0], e.Args[1], value}}, nil
		}

		return nil, token_error(equals, "Invalid assignment target,")
	}

	return ret, nil
}

func parse_infix(
	tks []token,
	idx *int,
	next func([]token, *int) (ret Exp, err error),
	ts []string,
) (ret Exp, err error) {
	infix_map := map[string]string{
		"SLASH":      "__div",
		"STAR":       "__mul",
		"MINUS":      "__sub",
		"PLUS":       "__add",
		"GREATER":    "__gt",
		"GREATER_EQ": "__geq",
		"LESS":       "__lt",
		"LESS_EQ":    "__leq",
		"BANG_EQ":    "__neq",
		"EQ_EQ":      "__eq",
		"AND":        "__and",
		"OR":         "__or",
	}

	ret, err = next(tks, idx)
	if err != nil {
		return nil, err
	}

	i := parse_multimatch(tks, idx, ts)
	for i >= 0 {
		next_exp, err := next(tks, idx)
		if err != nil {
			return nil, err
		}

		exp := Call{intern(infix_map[ts[i]]), List{ret, next_exp}}
		ret = &exp

		i = parse_multimatch(tks, idx, ts)
	}

	return ret, nil
}

func parse_lor(tks []token, idx *int) (ret Exp, err error) {
	return parse_infix(tks, idx, parse_land, []string{"OR"})
}

func parse_land(tks []token, idx *int) (ret Exp, err error) {
	return parse_infix(tks, idx, parse_eqty, []string{"AND"})
}

func parse_eqty(tks []token, idx *int) (ret Exp, err error) {
	return parse_infix(tks, idx, parse_comp, []string{"BANG_EQ", "EQ_EQ"})
}

func parse_comp(tks []token, idx *int) (ret Exp, err error) {
	return parse_infix(tks, idx, parse_term, []string{"GREATER", "GREATER_EQ", "LESS", "LESS_EQ"})
}

func parse_term(tks []token, idx *int) (ret Exp, err error) {
	return parse_infix(tks, idx, parse_fact, []string{"MINUS", "PLUS"})
}

func parse_fact(tks []token, idx *int) (ret Exp, err error) {
	return parse_infix(tks, idx, parse_unary, []string{"SLASH", "STAR"})
}

func parse_unary(tks []token, idx *int) (ret Exp, err error) {
	if parse_match(tks, idx, "BANG") {
		y, err := parse_unary(tks, idx)
		if err != nil {
			return nil, err
		}

		return &Call{intern("__not"), List{y}}, nil
	}
	if parse_match(tks, idx, "MINUS") {
		y, err := parse_unary(tks, idx)
		if err != nil {
			return nil, err
		}

		return &Call{intern("__neg"), List{y}}, nil
	}

	return parse_call(tks, idx)
}

func parse_call(tks []token, idx *int) (ret Exp, err error) {
	ret, err = parse_primary(tks, idx)
	if err != nil {
		return nil, err
	}

	for {
		if parse_match(tks, idx, "LPAREN") {
			var args List
			if !parse_check(tks, idx, "RPAREN") {
				for {
					if len(args) >= 255 {
						return nil, token_error(tks[*idx], "Cannot have more than 255 args.")
					}

					app, err := parse_expr(tks, idx)
					if err != nil {
						return nil, err
					}

					args = append(args, app)
					if !parse_match(tks, idx, "COMMA") {
						break
					}
				}
			}

			_, err = parse_consume(tks, idx, "RPAREN", "Expected ')' after arguments.")
			if err != nil {
				return nil, err
			}

			ret = &Call{ret, args}
		} else if parse_match(tks, idx, "DOT") {
			tok, err := parse_consume(tks, idx, "SYM", "Expected field after '.'")
			if err != nil {
				return nil, err
			}

			sym := String(tok.literal.(string))
			ret = &Call{intern("__get"), List{ret, &sym}}
		} else if parse_match(tks, idx, "LBRACK") {
			x, err := parse_expr(tks, idx)
			if err != nil {
				return nil, err
			}

			c := &Call{intern("__get"), List{ret, x}}
			_, err = parse_consume(tks, idx, "RBRACK", "Expected ']' after field access.")
			if err != nil {
				return nil, err
			}

			ret = c
		} else if parse_match(tks, idx, "COLON") {
			tok, err := parse_consume(tks, idx, "SYM", "Expected Symbol after ':'")
			if err != nil {
				return nil, err
			}
			_, err = parse_consume(tks, idx, "LPAREN", "Expected '(' after selfcall.")
			if err != nil {
				return nil, err
			}

			var args List
			if !parse_check(tks, idx, "RPAREN") {
				for {
					if len(args) >= 255 {
						return nil, token_error(tks[*idx], "Cannot have more than 255 args.")
					}
					e, err := parse_expr(tks, idx)
					if err != nil {
						return nil, err
					}
					args = append(args, e)
					if !parse_match(tks, idx, "COMMA") {
						break
					}
				}
			}
			_, err = parse_consume(tks, idx, "RPAREN", "Expected ')' after arguments.")
			if err != nil {
				return nil, err
			}
			str := String(tok.literal.(string))
			return &Call{intern("__selfcall"), List{ret, &str, &args}}, nil
		} else {
			break
		}
	}

	return ret, nil
}

func parse_primary(tks []token, idx *int) (ret Exp, err error) {
	if parse_match(tks, idx, "TRUE") {
		x := Boolean(true)
		return &x, nil
	}
	if parse_match(tks, idx, "FALSE") {
		x := Boolean(false)
		return &x, nil
	}
	if parse_match(tks, idx, "NIL") {
		return &Special_nil, nil
	}
	if parse_match(tks, idx, "NUM") {
		if num, ok := tks[*idx-1].literal.(float64); ok {
			x := Number(num)
			return &x, nil
		}
		return nil, token_error(tks[*idx], "Mismatched literal and token values.")
	}
	if parse_match(tks, idx, "STR") {
		if str, ok := tks[*idx-1].literal.(string); ok {
			x := String(str)
			return &x, nil
		}
		return nil, token_error(tks[*idx], "Mismatched literal and token values.")
	}

	if parse_match(tks, idx, "SYM") {
		if sym, ok := tks[*idx-1].literal.(string); ok {
			return intern(sym), nil
		}
		return nil, token_error(tks[*idx], "Mismatched literal and token values.")
	}
	if parse_match(tks, idx, "LCURLY") {
		return parse_thing(tks, idx)
	}
	if parse_match(tks, idx, "LBRACK") {
		return parse_list(tks, idx)
	}
	if parse_match(tks, idx, "LPAREN") {
		x, err := parse_expr(tks, idx)
		if err != nil {
			return nil, err
		}

		_, err = parse_consume(tks, idx, "RPAREN", "Expect ')' after grouping expression.")
		if err != nil {
			return nil, err
		}

		return x, nil
	}

	return nil, token_error(tks[*idx], "Unexpected expression.")
}

func parse_thing(tks []token, idx *int) (ret Exp, err error) {
	var fields List
	if !parse_check(tks, idx, "LCURLY") {
		i := 0

		for {
			if parse_match(tks, idx, "LBRACK") {
				e, err := parse_expr(tks, idx)
				if err != nil {
					return nil, err
				}
				fields = append(fields, e)

				_, err = parse_consume(tks, idx, "RBRACK", "Expect ']' after bracket field.")
				if err != nil {
					return nil, err
				}
				_, err = parse_consume(tks, idx, "EQ", "Expect '=' after field.")
				if err != nil {
					return nil, err
				}
			} else if parse_match(tks, idx, "DOT") {
				tok, err := parse_consume(tks, idx, "SYM", "Expected Symbol in dot field.")
				if err != nil {
					return nil, err
				}
				fields = append(fields, intern(tok.literal.(string)))
				_, err = parse_consume(tks, idx, "EQ", "Expect '=' after field.")
				if err != nil {
					return nil, err
				}
			} else if parse_check(tks, idx, "RCURLY") {
				break
			} else {
				x := Number(i)
				fields = append(fields, &x)
				i++
			}

			e, err := parse_expr(tks, idx)
			if err != nil {
				return nil, err
			}
			fields = append(fields, e)

			if !parse_match(tks, idx, "COMMA") {
				break
			}
		}
	}

	_, err = parse_consume(tks, idx, "RCURLY", "Expect '}' after field list.")
	if err != nil {
		return nil, err
	}

	return &Call{intern("__thing"), fields}, nil

}

func parse_list(tks []token, idx *int) (ret Exp, err error) {
	var elems List

	if !parse_check(tks, idx, "RBRACK") {
		for {
			e, err := parse_expr(tks, idx)
			if err != nil {
				return nil, err
			}

			elems = append(elems, e)

			if !parse_match(tks, idx, "COMMA") {
				break
			}
		}
	}

	_, err = parse_consume(tks, idx, "RBRACK", "Expect ']' after list expression.")
	if err != nil {
		return nil, err
	}

	return &Call{intern("__list"), elems}, nil
}

// --- EVALUATION SECTION ---

func eval_through_tco(env *Env, list List, catch Exp) (Exp, RetVal, error) {
	if len(list) == 0 {
		return &Special_nil, RetVal{}, nil
	}

	// fmt.Printf("[eval_through_tco] i adr before: %v\n", (*env).Get(intern("i")))
	// fmt.Printf("[eval_through_tco] i val before: %v\n", float64((*(*env).Get(intern("i"))).(Number)))

	for i := 0; i < len(list)-1; i++ {
		_, rval, err := eval(env, list[i], catch)
		if err != nil {
			return nil, RetVal{}, err
		}
		if rval.Fun != nil {
			return nil, rval, nil
		}
	}

	// fmt.Printf("[eval_through_tco] i adr after*: %v\n", (*env).Get(intern("i")))
	// fmt.Printf("[eval_through_tco] i val after*: %v\n", float64((*(*env).Get(intern("i"))).(Number)))

	return list[len(list)-1], RetVal{}, nil
}

func eval_list(env *Env, list List, catch Exp) (List, RetVal, error) {
	// fmt.Printf("[eval_list] list before: %v\n", list.As_string())
	// println("inside eval_list")
	var ret List

	for i, _ := range list {
		// println("calling eval on " + (*list[i]).As_string())
		// fmt.Printf("i: %v\n", i)

		item, rval, err := eval(env, list[i], catch)

		if err != nil {
			return nil, RetVal{}, err
		}

		if rval.Fun != nil {
			return nil, rval, nil
		}

		// list[i] = item
		ret = append(ret, item)
	}

	// fmt.Printf("[eval_list] list after: %v\n", list.As_string())

	// return list, RetVal{}, nil
	return ret, RetVal{}, nil
}

func eval(env *Env, exp Exp, upper_catch Exp) (immediate Exp, return_value RetVal, rerr error) {
	for {
		var name string
		if DEBUG {
			if t := reflect.TypeOf(exp); t.Kind() == reflect.Ptr {
				name = "*" + t.Elem().Name()
			} else {
				name = t.Name()
			}

			log.Printf("Evaluating: (%p) %v::%v\n", exp, name, exp.As_string())
			bufio.NewReader(os.Stdin).ReadString('\n')
		}

		switch value := exp.(type) {
		case *Number:
			return exp, RetVal{}, nil

		case *String:
			return exp, RetVal{}, nil

		case *Boolean:
			return exp, RetVal{}, nil

		case *Thing:
			return exp, RetVal{}, nil

		case *Primitive:
			return exp, RetVal{}, nil

		case *Procedure:
			return exp, RetVal{}, nil

		case *Special:
			return exp, RetVal{}, nil

		case *Symbol:
			bind := (*env).Get(*value)
			log.Printf("  symbol ptr: %p\n", bind)
			if bind != nil {
				log.Printf("  symbol val: %v\n", bind.As_string())
			}
			log.Println()

			if bind == nil {
				// fmt.Printf("eval::Symbol erroring out\n")
				return nil, RetVal{}, fmt.Errorf("eval: Undefined symbol '%v'", value.As_string())
			}
			return bind, RetVal{}, nil

		case *Call:
			fun, rval, err := eval(env, value.Name, upper_catch)
			if err != nil {
				// println("eval::Call erroring out")
				return nil, RetVal{}, err
			}
			if rval.Fun != nil {
				return nil, rval, nil
			}

			arg := value.Args

			// var fun_name string
			// if t := reflect.TypeOf(*exp); t.Kind() == reflect.Ptr {
			// 	name = "*" + t.Elem().Name()
			// } else {
			// 	name = t.Name()
			// }

			// println("fun is a " + name)

			switch execution := fun.(type) {
			case *Procedure:
				this_catch_value := Special(fmt.Sprintf("procedure %v", fun))
				this_catch := &this_catch_value

				farg, rval, err := eval_list(env, arg, this_catch)
				if err != nil {
					return nil, RetVal{}, err
				}
				if rval.Fun != nil {
					if rval.Fun == this_catch {
						return rval.Val, RetVal{}, nil
					}

					return nil, rval, nil
				}

				fenv := execution.Env

				new_env, err := Make_env(fenv, execution.Params, farg)
				if err != nil {
					return nil, RetVal{}, nil
				}

				env = new_env

				texp, rval, err := eval_through_tco(env, execution.Body, this_catch)
				if err != nil {
					return nil, RetVal{}, err
				}
				if rval.Fun != nil {
					if rval.Fun == this_catch {
						return rval.Val, RetVal{}, nil
					}

					return nil, rval, nil
				}

				exp = texp

				// TCO return handling. VERY UGLY

				if c, is_call := exp.(*Call); is_call {
					if s, is_symbol := c.Name.(*Symbol); is_symbol && string(*s) == "__return" {
						e, rval, err := eval(env, c.Args[0], this_catch)
						if err != nil {
							return nil, RetVal{}, err
						}
						if rval.Fun != nil {
							if rval.Fun == this_catch {
								return rval.Val, RetVal{}, nil
							}

							return nil, rval, nil
						}

						return e, RetVal{}, nil
					}
				}
			case *Primitive:
				exp, rval, err = execution.Fun(env, arg, upper_catch)

				log.Printf("  %v (%p) result ptr: %v\n", execution.Name, execution, exp)
				if exp != nil {
					log.Printf("  %v (%p) result val: %v\n", execution.Name, execution, exp.As_string())
				}
				log.Println()

				if err != nil {
					// println("eval::Call::Primitive erroring out")

					return nil, RetVal{}, err
				}
				if rval.Fun != nil {
					return nil, rval, nil
				}

				if !execution.Tco {
					return exp, RetVal{}, nil
				}
			default:
				return nil, RetVal{}, fmt.Errorf("eval: Call must be PRIMITIVE or PROCEDURE.")
			}

			continue

		case *List:
			return nil, RetVal{}, fmt.Errorf("eval: Attempted to evaluate List.")

		default:
			return nil, RetVal{}, fmt.Errorf("eval: Unknown exp type.")
		}
	}
}

var DEBUG bool

// var LOG *log.Logger

func main() {
	DEBUG = true
	DEBUG = false

	var log_output io.Writer

	if DEBUG {
		log_output = os.Stdout
	} else {
		log_output = io.Discard
	}

	log.SetOutput(log_output)
	log.SetFlags(0)

	obmap = make(map[string]Exp)

	Special_nil = Special("nil")
	Special_top_scope = Special("top_scope")

	env := standard_env()

	filename := flag.String("i", "", "")
	flag.Parse()

	repl := (*filename == "")
	reader := bufio.NewReader(os.Stdin)

	for mainLoop := true; mainLoop; mainLoop = repl {
		var s string

		if repl {
			fmt.Print("> ")
			s, _ = reader.ReadString('\n')
		} else {
			raw, _ := os.ReadFile(*filename)
			s = string(raw)
		}

		// fmt.Println("BEFORE TOKENIZE")

		tokens, _ := tokenize(s)

		// fmt.Println("TOKENS:")
		// for _, e := range tokens {
		// 	fmt.Print(e.kind + " " + e.lexeme + " ")
		// 	fmt.Println(e.literal)
		// }

		// fmt.Println("EXPRS:")

		exprs, err := parse(tokens)
		if err != nil {
			fmt.Println(err)
			continue
		}

		for _, e := range exprs {

			log.Println(e.As_string())

			e, rval, err := eval(env, e, &Special_top_scope)
			// fmt.Printf("%v\n", err)
			if err != nil {
				// fmt.Println(err)
				panic(err)
			}

			if rval.Fun != nil {
				if rval.Fun != &Special_top_scope {
					fmt.Println("Mismatched return catch.")
					panic(1)
				}

				if repl {
					fmt.Println(rval.Val.As_string())
				}
			} else if repl {
				fmt.Println(e.As_string())
			}
		}
	}
}
